import 'dart:convert';

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:flutter_map/flutter_map.dart';
import 'package:latlong2/latlong.dart';
import 'package:geolocator/geolocator.dart';
import 'package:firebase_database/firebase_database.dart';
import 'dart:async';
import 'dart:math';
import '../../providers/auth_provider.dart';
import '../../services/driver_location_service.dart';
import '../../services/api_service.dart';
import '../../models/order.dart';
import '../auth/phone_input_screen.dart';
import 'orders_screen.dart';
import 'trip_sharing_screen.dart';
import 'statistics_screen.dart';
import 'history_screen.dart';
import 'invite_friends_screen.dart';
import 'settings_screen.dart';
import 'profile_detail_screen.dart';
import 'real_time_map_screen.dart';
import '../../test/gps_test_screen.dart';

class HomeScreen extends StatefulWidget {
  const HomeScreen({Key? key}) : super(key: key);

  @override
  State<HomeScreen> createState() => _HomeScreenState();
}

class _HomeScreenState extends State<HomeScreen> {
  final MapController _mapController = MapController();
  Position? _currentPosition;
  Timer? _locationUpdateTimer;
  List<LatLng> _locationHistory = [];
  String _locationStatus = 'ƒêang kh·ªüi t·∫°o GPS...';
  String _lastUpdateTime = '';
  bool _isMapReady = false;
  int _totalUpdates = 0;
  int _successfulUpdates = 0;

  // Cached orders data
  List<Order>? _cachedOrders;
  DateTime? _lastOrdersFetchTime;
  static const Duration _ordersCacheDuration = Duration(minutes: 5); // Cache for 5 minutes

  // Auto proximity checking
  Timer? _proximityCheckTimer;
  bool _isAutoProximityChecking = false;
  
  // Global orders data for proximity checking
  List<Order>? _activeOrders;
  bool _hasLoadedOrders = false;
  
  // Track orders that have been marked as arrived
  Set<int> _arrivedOrders = {};

  // Default location (Hanoi)
  static const LatLng _defaultLocation = LatLng(21.0285, 105.8542);

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _checkAndStartTracking();
    });
  }

  void _checkAndStartTracking() {
    final authProvider = Provider.of<AuthProvider>(context, listen: false);
    if (authProvider.isOnline) {
      _initializeLocationTracking();
    }
  }

  @override
  void dispose() {
    _locationUpdateTimer?.cancel();
    _proximityCheckTimer?.cancel();
    super.dispose();
  }

  Future<void> _initializeLocationTracking() async {
    final authProvider = Provider.of<AuthProvider>(context, listen: false);

    if (!authProvider.isOnline) {
      setState(() {
        _locationStatus = 'T√†i x·∫ø offline - ch∆∞a b·∫≠t GPS tracking';
      });
      return;
    }

    try {
      setState(() {
        _locationStatus = 'ƒêang ki·ªÉm tra quy·ªÅn GPS...';
      });

      bool serviceEnabled = await Geolocator.isLocationServiceEnabled();
      if (!serviceEnabled) {
        setState(() {
          _locationStatus = 'GPS ch∆∞a ƒë∆∞·ª£c b·∫≠t tr√™n thi·∫øt b·ªã';
        });
        return;
      }

      LocationPermission permission = await Geolocator.checkPermission();
      if (permission == LocationPermission.denied) {
        permission = await Geolocator.requestPermission();
        if (permission == LocationPermission.denied) {
          setState(() {
            _locationStatus = 'Quy·ªÅn GPS b·ªã t·ª´ ch·ªëi';
          });
          return;
        }
      }

      if (permission == LocationPermission.deniedForever) {
        setState(() {
          _locationStatus = 'Quy·ªÅn GPS b·ªã t·ª´ ch·ªëi vƒ©nh vi·ªÖn';
        });
        return;
      }

      await _getCurrentLocation();
      _startLocationTracking();

      setState(() {
        _locationStatus = 'GPS ƒëang ho·∫°t ƒë·ªông';
      });
    } catch (e) {
      setState(() {
        _locationStatus = 'L·ªói kh·ªüi t·∫°o GPS: $e';
      });
    }
  }

  Future<void> _getCurrentLocation() async {
    try {
      Position position = await Geolocator.getCurrentPosition(
        desiredAccuracy: LocationAccuracy.high,
        timeLimit: Duration(seconds: 10),
      );

      setState(() {
        _currentPosition = position;
        _lastUpdateTime = DateTime.now().toString().substring(11, 19);
      });

      LatLng newPoint = LatLng(position.latitude, position.longitude);
      _locationHistory.add(newPoint);

      if (_locationHistory.length > 50) {
        _locationHistory.removeAt(0);
      }

      if (!_isMapReady) {
        _mapController.move(newPoint, 16.0);
        setState(() {
          _isMapReady = true;
        });
      }

      print('üìç GPS Updated: ${position.latitude}, ${position.longitude}');
    } catch (e) {
      print('‚ùå Error getting current location: $e');
    }
  }

  /// H√†m g·ª≠i t·ªça ƒë·ªô l√™n Firebase t·ª´ _getCurrentLocation
  Future<void> _sendLocationToFirebaseFromGetLocation(Position position) async {
    try {
      // L·∫•y driverId t·ª´ authProvider
      final authProvider = Provider.of<AuthProvider>(context, listen: false);
      final driverId = authProvider.driver?.id?.toString() ?? 'unknown';

      // T·∫°o d·ªØ li·ªáu location theo c·∫•u tr√∫c Firebase y√™u c·∫ßu
      Map<String, dynamic> locationData = {
        'accuracy': position.accuracy,
        'bearing': position.heading ?? 0.0,
        'isOnline': true,
        'latitude': position.latitude,
        'longitude': position.longitude,
        'speed': position.speed ?? 0.0,
        'status': 1,
        'timestamp': DateTime.now().millisecondsSinceEpoch,
      };

      // S·ª≠ d·ª•ng Firebase Database instance m·∫∑c ƒë·ªãnh
      final DatabaseReference database = FirebaseDatabase.instance.ref();
      print("üìç Sending location to Firebase: $locationData");
      // G·ª≠i l√™n Firebase theo ƒë∆∞·ªùng d·∫´n: realtime-locations/{driverId}
      await database
          .child('realtime-locations')
          .child(driverId)
          .set(locationData);

      print('üìç Location auto-sent to Firebase from _getCurrentLocation: userId=$driverId, lat=${position.latitude}, lng=${position.longitude}');
    } catch (e) {
      print('‚ùå Error auto-sending location to Firebase from _getCurrentLocation: $e');
    }
  }

  void _startLocationTracking() {
    // Thay ƒë·ªïi interval th√†nh 5 gi√¢y v√† g·ª≠i l√™n Firebase
    _locationUpdateTimer = Timer.periodic(Duration(seconds: 5), (timer) async {
      final authProvider = Provider.of<AuthProvider>(context, listen: false);

      if (authProvider.isOnline) {
        await _getCurrentLocation();
        await _sendLocationToFirebase(); // G·ª≠i l√™n Firebase m·ªói 5s
         // Ki·ªÉm tra kho·∫£ng c√°ch ƒë·∫øn ƒë·ªãa ƒëi·ªÉm giao h√†ng
      } else {
        setState(() {
          _locationStatus = 'T√†i x·∫ø offline - d·ª´ng tracking';
        });
        timer.cancel();
      }
    });
  }

  Future<void> _sendLocationToServer() async {
    if (_currentPosition == null) return;

    try {
      _totalUpdates++;
      await DriverLocationService.updateLocationNow();
      // await _addLocationToFirebase()
      setState(() {
        _successfulUpdates++;
      });
      print('‚úÖ Location sent to server successfully');
    } catch (e) {
      print('‚ùå Failed to send location to server: $e');
    }
  }

  /// H√†m g·ª≠i t·ªça ƒë·ªô l√™n Firebase theo c·∫•u tr√∫c y√™u c·∫ßu
  Future<void> _sendLocationToFirebase() async {
    try {
      print("üöÄ Starting _sendLocationToFirebase function");

      // L·∫•y v·ªã tr√≠ hi·ªán t·∫°i
      Position? position;

      if (_currentPosition == null) {
        // N·∫øu ch∆∞a c√≥ v·ªã tr√≠, l·∫•y v·ªã tr√≠ hi·ªán t·∫°i
        try {
          position = await Geolocator.getCurrentPosition(
            desiredAccuracy: LocationAccuracy.high,
            timeLimit: Duration(seconds: 10),
          );
          setState(() {
            _currentPosition = position;
          });
        } catch (e) {
          print("‚ùå Error getting current position: $e");
          return;
        }
      } else {
        position = _currentPosition;
      }

      // L·∫•y driverId t·ª´ authProvider
      final authProvider = Provider.of<AuthProvider>(context, listen: false);
      final driverId = authProvider.driver?.id?.toString() ?? 'unknown';
      print("üîë Driver ID: $driverId");

      // T·∫°o d·ªØ li·ªáu location theo c·∫•u tr√∫c Firebase y√™u c·∫ßu
      Map<String, dynamic> locationData = {
        'accuracy': position!.accuracy,
        'bearing': position.heading ?? 0.0,
        'isOnline': true,
        'latitude': position.latitude,
        'longitude': position.longitude,
        'speed': position.speed ?? 0.0,
        'status': 1,
        'timestamp': DateTime.now().millisecondsSinceEpoch,
      };

      print("üìç Location data prepared: $locationData");

      // S·ª≠ d·ª•ng Firebase Database instance m·∫∑c ƒë·ªãnh
      final DatabaseReference database = FirebaseDatabase.instance.ref();
      print("üî• Firebase database instance created: ${database.toString()}");

      print("‚è≥ About to send to Firebase...");

      // G·ª≠i l√™n Firebase theo ƒë∆∞·ªùng d·∫´n: realtime-locations/{driverId}
      try {
        await database
            .child('realtime-locations')
            .child(driverId)
            .set(locationData)
            .timeout(Duration(seconds: 15)); // Add timeout

        print("‚úÖ Firebase set operation completed successfully!");
        print("üéØ G·ª≠i t·ªça ƒë·ªô l√™n firebase th√†nh c√¥ng: ${database.toString()}");

      } catch (firebaseError) {
        print("üí• Firebase set operation failed: $firebaseError");
        print("üîç Error type: ${firebaseError.runtimeType}");
        throw firebaseError; // Re-throw to be caught by outer catch
      }

      // C·∫≠p nh·∫≠t UI
      setState(() {
        _lastUpdateTime = DateTime.now().toString().substring(11, 19);
        _successfulUpdates++;
        _totalUpdates++;
      });

      print('‚úÖ Location sent to Firebase successfully:');
      print('   URL: https://delivery-0805-default-rtdb.firebaseio.com/realtime-locations/$driverId');
      print('   Data: $locationData');

    } catch (e) {
      // Hi·ªÉn th·ªã l·ªói chi ti·∫øt
      print('üí• DETAILED ERROR in _sendLocationToFirebase: $e');
      print('üîç Error type: ${e.runtimeType}');
      print('üîç Error toString: ${e.toString()}');

      // Hi·ªÉn th·ªã l·ªói tr√™n UI n·∫øu c·∫ßn
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('‚ùå L·ªói g·ª≠i t·ªça ƒë·ªô l√™n Firebase: $e'),
            backgroundColor: Colors.red,
            duration: Duration(seconds: 3),
          ),
        );
      }
    }
  }

  /// Ki·ªÉm tra xem ƒë∆°n h√†ng c√≥ ƒëang trong qu√° tr√¨nh giao kh√¥ng
  bool _isOrderInDelivery(int statusCode) {
    // Status code meanings:
    // 0: Ch·ªù x√°c nh·∫≠n
    // 1: ƒê√£ nh·∫≠n ƒë∆°n, ƒëang giao
    // 2: ƒêang giao h√†ng
    // 3: ƒê√£ giao xong
    // 4: ƒê√£ h·ªßy
    return statusCode == 1 || statusCode == 2;
  }

  /// Ki·ªÉm tra xem ƒë∆°n h√†ng c√≥ th·ªÉ ki·ªÉm tra kho·∫£ng c√°ch kh√¥ng
  bool _canCheckProximity(int statusCode) {
    // Ch·ªâ ki·ªÉm tra ƒë∆°n h√†ng ƒëang giao (status 1, 2) v√† ch∆∞a ho√†n th√†nh (status 3)
    return statusCode == 1 || statusCode == 2;
  }

  /// Chuy·ªÉn ƒë·ªïi status code th√†nh text
  String _getStatusText(int statusCode) {
    switch (statusCode) {
      case 0:
        return 'Ch·ªù x√°c nh·∫≠n';
      case 1:
        return 'ƒê√£ nh·∫≠n ƒë∆°n';
      case 2:
        return 'ƒêang giao';
      case 3:
        return 'ƒê√£ giao xong';
      case 4:
        return 'ƒê√£ h·ªßy';
      default:
        return 'Kh√¥ng x√°c ƒë·ªãnh';
    }
  }

  /// C·∫≠p nh·∫≠t tr·∫°ng th√°i ƒë∆°n h√†ng th√†nh "ƒë√£ t·ªõi" l√™n server
  Future<void> _updateOrderArrivedStatus(int orderId, double distance) async {
    try {
      print('üîÑ ƒêang c·∫≠p nh·∫≠t tr·∫°ng th√°i ƒë∆°n h√†ng $orderId th√†nh "ƒë√£ t·ªõi"...');
      
      final apiService = ApiService();
      final note = 'Driver arrived at delivery location. Distance: ${distance.toStringAsFixed(1)}m';
      
      final response = await apiService.updateOrderArrived(orderId, note: note);

      if (response.success && response.data != null) {
        print('‚úÖ ƒê√£ c·∫≠p nh·∫≠t tr·∫°ng th√°i ƒë∆°n h√†ng $orderId th√†nh c√¥ng');
        
        // C·∫≠p nh·∫≠t ƒë∆°n h√†ng trong danh s√°ch local
        _updateLocalOrderStatus(orderId, response.data!);
        
        // Hi·ªÉn th·ªã th√¥ng b√°o th√†nh c√¥ng
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('‚úÖ ƒê√£ c·∫≠p nh·∫≠t tr·∫°ng th√°i ƒë∆°n h√†ng #$orderId'),
              backgroundColor: Colors.green,
              duration: Duration(seconds: 3),
            ),
          );
        }
      } else {
        print('‚ùå L·ªói c·∫≠p nh·∫≠t tr·∫°ng th√°i ƒë∆°n h√†ng: ${response.message}');
        
        // X√≥a kh·ªèi danh s√°ch ƒë√£ x·ª≠ l√Ω ƒë·ªÉ c√≥ th·ªÉ th·ª≠ l·∫°i
        _arrivedOrders.remove(orderId);
        
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('‚ùå L·ªói c·∫≠p nh·∫≠t tr·∫°ng th√°i: ${response.message}'),
              backgroundColor: Colors.red,
              duration: Duration(seconds: 3),
            ),
          );
        }
      }
    } catch (e) {
      print('üí• L·ªói khi c·∫≠p nh·∫≠t tr·∫°ng th√°i ƒë∆°n h√†ng: $e');
      
      // X√≥a kh·ªèi danh s√°ch ƒë√£ x·ª≠ l√Ω ƒë·ªÉ c√≥ th·ªÉ th·ª≠ l·∫°i
      _arrivedOrders.remove(orderId);
      
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('üí• L·ªói k·∫øt n·ªëi: $e'),
            backgroundColor: Colors.red,
            duration: Duration(seconds: 3),
          ),
        );
      }
    }
  }

  /// C·∫≠p nh·∫≠t tr·∫°ng th√°i ƒë∆°n h√†ng trong danh s√°ch local
  void _updateLocalOrderStatus(int orderId, Order updatedOrder) {
    if (_activeOrders != null) {
      final index = _activeOrders!.indexWhere((order) => order.id == orderId);
      if (index != -1) {
        _activeOrders![index] = updatedOrder;
        print('üìù ƒê√£ c·∫≠p nh·∫≠t tr·∫°ng th√°i ƒë∆°n h√†ng $orderId trong danh s√°ch local');
        
        // Ki·ªÉm tra xem c√≤n ƒë∆°n h√†ng n√†o c·∫ßn theo d√µi kh√¥ng
        _checkIfShouldStopProximityChecking();
      }
    }
  }

  /// Ki·ªÉm tra xem c√≥ n√™n d·ª´ng ki·ªÉm tra kho·∫£ng c√°ch kh√¥ng
  void _checkIfShouldStopProximityChecking() {
    if (_activeOrders == null) return;
    
    final remainingOrders = _activeOrders!.where((order) => 
      _canCheckProximity(order.statusCode)
    ).toList();
    
    if (remainingOrders.isEmpty && _isAutoProximityChecking) {
      print('üì¶ Kh√¥ng c√≤n ƒë∆°n h√†ng n√†o c·∫ßn theo d√µi, d·ª´ng ki·ªÉm tra kho·∫£ng c√°ch');
      
      // D·ª´ng timer
      _proximityCheckTimer?.cancel();
      _proximityCheckTimer = null;
      _isAutoProximityChecking = false;
      
      // Hi·ªÉn th·ªã th√¥ng b√°o
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('‚úÖ ƒê√£ ho√†n th√†nh t·∫•t c·∫£ ƒë∆°n h√†ng!'),
            backgroundColor: Colors.green,
            duration: Duration(seconds: 3),
          ),
        );
        
        // C·∫≠p nh·∫≠t UI
        setState(() {});
      }
    }
  }

  /// H√†m ki·ªÉm tra kho·∫£ng c√°ch ƒë·∫øn ƒë·ªãa ch·ªâ giao h√†ng (s·ª≠ d·ª•ng d·ªØ li·ªáu ƒë√£ load)
  Future<void> _checkProximityToDestination() async {
    try {
      print('üéØ B·∫Øt ƒë·∫ßu ki·ªÉm tra kho·∫£ng c√°ch...');

      // Ki·ªÉm tra xem ƒë√£ load ƒë∆°n h√†ng ch∆∞a
      if (!_hasLoadedOrders || _activeOrders == null) {
        print('‚ùå Ch∆∞a c√≥ d·ªØ li·ªáu ƒë∆°n h√†ng, vui l√≤ng b·∫•m n√∫t ƒë·ªÉ load tr∆∞·ªõc');
        return;
      }

      // L·∫•y v·ªã tr√≠ hi·ªán t·∫°i
      if (_currentPosition == null) {
        await _getCurrentLocation();
      }

      if (_currentPosition == null) {
        print('‚ùå Kh√¥ng th·ªÉ l·∫•y v·ªã tr√≠ hi·ªán t·∫°i');
        return;
      }

      print('üìç V·ªã tr√≠ hi·ªán t·∫°i: ${_currentPosition!.latitude}, ${_currentPosition!.longitude}');

      // Debug: In ra t·∫•t c·∫£ ƒë∆°n h√†ng v√† status code
      print('üìã T·ªïng s·ªë ƒë∆°n h√†ng: ${_activeOrders!.length}');
      for (final order in _activeOrders!) {
        print('   - ƒê∆°n h√†ng ${order.id}: status_code = ${order.statusCode}');
      }

      // L·ªçc ƒë∆°n h√†ng c√≥ th·ªÉ ki·ªÉm tra kho·∫£ng c√°ch
      final activeDeliveryOrders = _activeOrders!.where((order) => 
        _canCheckProximity(order.statusCode)
      ).toList();

      if (activeDeliveryOrders.isEmpty) {
        print('üì¶ Kh√¥ng c√≥ ƒë∆°n h√†ng n√†o ƒëang trong qu√° tr√¨nh giao');
        print('üì¶ C√°c ƒë∆°n h√†ng hi·ªán c√≥:');
        for (final order in _activeOrders!) {
          final statusText = _getStatusText(order.statusCode);
          print('   - ƒê∆°n h√†ng ${order.id}: status_code = ${order.statusCode} ($statusText)');
        }
        return;
      }

      print('üì¶ ƒêang ki·ªÉm tra ${activeDeliveryOrders.length} ƒë∆°n h√†ng ƒëang giao');

      // Ki·ªÉm tra t·ª´ng ƒë∆°n h√†ng
      for (final order in activeDeliveryOrders) {
        print('üöö Ki·ªÉm tra ƒë∆°n h√†ng ${order.id} (tr·∫°ng th√°i: ${order.statusCode})');

        // T√≠nh kho·∫£ng c√°ch t·ª´ v·ªã tr√≠ hi·ªán t·∫°i ƒë·∫øn ƒë·ªãa ch·ªâ giao h√†ng
        double distance = _calculateDistance(
          _currentPosition!.latitude,
          _currentPosition!.longitude,
          order.toAddress.lat,
          order.toAddress.lon,
        );

        print('üìè Kho·∫£ng c√°ch ƒë·∫øn ƒë∆°n h√†ng ${order.id}: ${distance.toStringAsFixed(2)}m');
        print('   ƒê·ªãa ch·ªâ: ${order.toAddress.desc}');
        print('   T·ªça ƒë·ªô: ${order.toAddress.lat}, ${order.toAddress.lon}');

        // N·∫øu kho·∫£ng c√°ch <= 10m v√† ch∆∞a ƒë∆∞·ª£c ƒë√°nh d·∫•u l√† ƒë√£ t·ªõi
        if (distance <= 10.0 && !_arrivedOrders.contains(order.id)) {
          print('üéâ ƒê√É T·ªöI! - ƒê∆°n h√†ng ${order.id}');
          print('   Kh√°ch h√†ng: ${order.customer.name} - ${order.customer.phone}');
          print('   Kho·∫£ng c√°ch: ${distance.toStringAsFixed(2)}m');
          print('   ƒê·ªãa ch·ªâ: ${order.toAddress.desc}');

          // ƒê√°nh d·∫•u ƒë∆°n h√†ng n√†y ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω
          _arrivedOrders.add(order.id);

          // C·∫≠p nh·∫≠t tr·∫°ng th√°i l√™n server
          await _updateOrderArrivedStatus(order.id, distance);

          // Hi·ªÉn th·ªã th√¥ng b√°o tr√™n UI
          if (mounted) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text('üéâ ƒê√É T·ªöI ƒë·ªãa ch·ªâ giao h√†ng!\nKho·∫£ng c√°ch: ${distance.toStringAsFixed(1)}m\nKh√°ch h√†ng: ${order.customer.name}'),
                backgroundColor: Colors.green,
                duration: Duration(seconds: 5),
                action: SnackBarAction(
                  label: 'Chi ti·∫øt',
                  textColor: Colors.white,
                  onPressed: () {
                    // C√≥ th·ªÉ m·ªü m√†n h√¨nh chi ti·∫øt ƒë∆°n h√†ng
                  },
                ),
              ),
            );
          }
        }
      }

    } catch (e) {
      print('‚ùå L·ªói khi ki·ªÉm tra kho·∫£ng c√°ch: $e');
    }
  }

  /// Load ƒë∆°n h√†ng t·ª´ API m·ªôt l·∫ßn duy nh·∫•t
  Future<void> _loadOrdersOnce() async {
    try {
      print('üîÑ ƒêang t·∫£i d·ªØ li·ªáu ƒë∆°n h√†ng t·ª´ API...');
      
      final apiService = ApiService();
      final ordersResponse = await apiService.getDriverOrders();

      if (!ordersResponse.success || ordersResponse.data == null) {
        print('‚ùå Kh√¥ng th·ªÉ t·∫£i ƒë∆°n h√†ng: ${ordersResponse.message}');
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('‚ùå L·ªói t·∫£i ƒë∆°n h√†ng: ${ordersResponse.message}'),
              backgroundColor: Colors.red,
              duration: Duration(seconds: 3),
            ),
          );
        }
        return;
      }

      // L∆∞u v√†o bi·∫øn to√†n c·ª•c
      _activeOrders = ordersResponse.data!;
      _hasLoadedOrders = true;
      
      // Reset danh s√°ch ƒë∆°n h√†ng ƒë√£ x·ª≠ l√Ω khi load d·ªØ li·ªáu m·ªõi
      _arrivedOrders.clear();

      print('‚úÖ ƒê√£ t·∫£i th√†nh c√¥ng ${_activeOrders!.length} ƒë∆°n h√†ng');
      
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('‚úÖ ƒê√£ t·∫£i ${_activeOrders!.length} ƒë∆°n h√†ng th√†nh c√¥ng'),
            backgroundColor: Colors.green,
            duration: Duration(seconds: 2),
          ),
        );
      }

    } catch (e) {
      print('‚ùå L·ªói khi t·∫£i ƒë∆°n h√†ng: $e');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('‚ùå L·ªói k·∫øt n·ªëi: $e'),
            backgroundColor: Colors.red,
            duration: Duration(seconds: 3),
          ),
        );
      }
    }
  }

  /// B·∫≠t/t·∫Øt ch·∫ø ƒë·ªô ki·ªÉm tra kho·∫£ng c√°ch t·ª± ƒë·ªông
  void _toggleAutoProximityChecking() async {
    if (_isAutoProximityChecking) {
      // T·∫Øt ch·∫ø ƒë·ªô t·ª± ƒë·ªông
      _proximityCheckTimer?.cancel();
      _proximityCheckTimer = null;
      _isAutoProximityChecking = false;
      
      print('‚èπÔ∏è ƒê√£ d·ª´ng ki·ªÉm tra kho·∫£ng c√°ch t·ª± ƒë·ªông');
      
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('‚èπÔ∏è ƒê√£ d·ª´ng ki·ªÉm tra kho·∫£ng c√°ch t·ª± ƒë·ªông'),
            backgroundColor: Colors.orange,
            duration: Duration(seconds: 2),
          ),
        );
      }
    } else {
      // Ki·ªÉm tra xem ƒë√£ load ƒë∆°n h√†ng ch∆∞a
      if (!_hasLoadedOrders) {
        print('üì¶ Ch∆∞a c√≥ d·ªØ li·ªáu ƒë∆°n h√†ng, ƒëang t·∫£i...');
        
        // Hi·ªÉn th·ªã th√¥ng b√°o ƒëang t·∫£i
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('üì¶ ƒêang t·∫£i d·ªØ li·ªáu ƒë∆°n h√†ng...'),
              backgroundColor: Colors.blue,
              duration: Duration(seconds: 1),
            ),
          );
        }
        
        // Load ƒë∆°n h√†ng tr∆∞·ªõc
        await _loadOrdersOnce();
        
        // Ki·ªÉm tra l·∫°i sau khi load
        if (!_hasLoadedOrders) {
          print('‚ùå Kh√¥ng th·ªÉ t·∫£i ƒë∆°n h√†ng, kh√¥ng th·ªÉ b·∫≠t ki·ªÉm tra t·ª± ƒë·ªông');
          return;
        }
      }
      
      // B·∫≠t ch·∫ø ƒë·ªô t·ª± ƒë·ªông
      _isAutoProximityChecking = true;
      print("üéØ B·∫Øt ƒë·∫ßu ki·ªÉm tra kho·∫£ng c√°ch t·ª± ƒë·ªông");
      
      // Ch·∫°y ki·ªÉm tra ngay l·∫≠p t·ª©c
      _checkProximityToDestination();
      
      // Thi·∫øt l·∫≠p timer ch·∫°y m·ªói 2 gi√¢y
      _proximityCheckTimer = Timer.periodic(Duration(seconds: 2), (timer) {
        if (_isAutoProximityChecking) {
          print("üìè ƒêang t√≠nh kho·∫£ng c√°ch...");
          _checkProximityToDestination();
        } else {
          timer.cancel();
        }
      });
      
      print('‚ñ∂Ô∏è ƒê√£ b·∫≠t ki·ªÉm tra kho·∫£ng c√°ch t·ª± ƒë·ªông (m·ªói 2 gi√¢y)');
      
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('‚ñ∂Ô∏è ƒê√£ b·∫≠t ki·ªÉm tra kho·∫£ng c√°ch t·ª± ƒë·ªông (m·ªói 2 gi√¢y)'),
            backgroundColor: Colors.green,
            duration: Duration(seconds: 2),
          ),
        );
      }
    }
    
    // C·∫≠p nh·∫≠t UI
    setState(() {});
  }

  /// H√†m t√≠nh kho·∫£ng c√°ch gi·ªØa 2 ƒëi·ªÉm GPS (Haversine formula)
  double _calculateDistance(double lat1, double lon1, double lat2, double lon2) {
    const double earthRadius = 6371000; // B√°n k√≠nh Tr√°i ƒê·∫•t t√≠nh b·∫±ng m√©t

    double dLat = _degreesToRadians(lat2 - lat1);
    double dLon = _degreesToRadians(lon2 - lon1);

    double a = sin(dLat / 2) * sin(dLat / 2) +
        cos(_degreesToRadians(lat1)) * cos(_degreesToRadians(lat2)) *
        sin(dLon / 2) * sin(dLon / 2);

    double c = 2 * atan2(sqrt(a), sqrt(1 - a));

    return earthRadius * c; // Kho·∫£ng c√°ch t√≠nh b·∫±ng m√©t
  }

  /// Chuy·ªÉn ƒë·ªïi ƒë·ªô sang radian
  double _degreesToRadians(double degrees) {
    return degrees * pi / 180;
  }

  /// H√†m l·∫•y danh s√°ch ƒë∆°n h√†ng v·ªõi cache
  Future<List<Order>?> _getOrdersWithCache() async {
    try {
      final now = DateTime.now();

      // Ki·ªÉm tra xem cache c√≤n hi·ªáu l·ª±c kh√¥ng
      if (_cachedOrders != null &&
          _lastOrdersFetchTime != null &&
          now.difference(_lastOrdersFetchTime!) < _ordersCacheDuration) {
        print('üì¶ Using cached orders (${_cachedOrders!.length} orders)');
        return _cachedOrders;
      }

      // Cache h·∫øt h·∫°n ho·∫∑c ch∆∞a c√≥ cache, g·ªçi API
      print('üîÑ Fetching fresh orders from API...');
      final apiService = ApiService();
      final ordersResponse = await apiService.getDriverOrders();

      if (!ordersResponse.success || ordersResponse.data == null) {
        print('‚ùå Failed to fetch orders: ${ordersResponse.message}');
        return null;
      }

      // L∆∞u v√†o cache
      _cachedOrders = ordersResponse.data!;
      _lastOrdersFetchTime = now;

      print('‚úÖ Orders cached successfully (${_cachedOrders!.length} orders)');
      return _cachedOrders;

    } catch (e) {
      print('‚ùå Error fetching orders: $e');
      return null;
    }
  }

  /// H√†m x√≥a cache ƒë∆°n h√†ng (g·ªçi khi c·∫ßn refresh)
  void _clearOrdersCache() {
    _cachedOrders = null;
    _lastOrdersFetchTime = null;
    print('üóëÔ∏è Orders cache cleared');
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      drawer: _buildDrawer(context),
      body: Consumer<AuthProvider>(
        builder: (context, authProvider, child) {
          if (authProvider.isLoading) {
            return const Center(
              child: CircularProgressIndicator(),
            );
          }

          if (authProvider.driver == null && !authProvider.isLoading) {
            // If driver is null and not loading, it means user logged out or auth failed
            // Use a post frame callback to avoid calling Navigator during build
            WidgetsBinding.instance.addPostFrameCallback((_) {
              if (mounted) {
                Navigator.pushAndRemoveUntil(
                  context,
                  MaterialPageRoute(
                    builder: (context) => const PhoneInputScreen(isLogin: true),
                  ),
                  (route) => false,
                );
              }
            });

            return const Scaffold(
              body: Center(
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    CircularProgressIndicator(),
                    SizedBox(height: 16),
                    Text('ƒêang chuy·ªÉn h∆∞·ªõng...'),
                  ],
                ),
              ),
            );
          }

          // Main content - GPS Tracking Map
          return Stack(
            children: [
              // Map with GPS tracking
              FlutterMap(
                mapController: _mapController,
                options: MapOptions(
                  center: _currentPosition != null
                      ? LatLng(_currentPosition!.latitude,
                          _currentPosition!.longitude)
                      : _defaultLocation,
                  zoom: 16.0,
                  maxZoom: 19.0,
                  minZoom: 10.0,
                ),
                children: [
                  // Map tiles
                  TileLayer(
                    urlTemplate:
                        'https://tile.openstreetmap.org/{z}/{x}/{y}.png',
                    userAgentPackageName: 'com.example.drive_app',
                  ),

                  // Location history trail
                  if (_locationHistory.length > 1)
                    PolylineLayer(
                      polylines: [
                        Polyline(
                          points: _locationHistory,
                          strokeWidth: 3.0,
                          color: Colors.blue.withOpacity(0.6),
                        ),
                      ],
                    ),

                  // Current location marker
                  MarkerLayer(
                    markers: [
                      // Current driver position
                      if (_currentPosition != null)
                        Marker(
                          point: LatLng(_currentPosition!.latitude,
                              _currentPosition!.longitude),
                          child: Container(
                            decoration: BoxDecoration(
                              color: Colors.blue,
                              shape: BoxShape.circle,
                              border: Border.all(color: Colors.white, width: 3),
                              boxShadow: [
                                BoxShadow(
                                  color: Colors.black26,
                                  blurRadius: 6,
                                  offset: Offset(0, 2),
                                ),
                              ],
                            ),
                            child: Icon(
                              Icons.navigation,
                              color: Colors.white,
                              size: 20,
                            ),
                            width: 30,
                            height: 30,
                          ),
                        ),

                      // Sample delivery locations
                      Marker(
                        point: LatLng(21.0245, 105.8412),
                        child: Container(
                          child: Icon(
                            Icons.local_shipping,
                            color: Colors.orange,
                            size: 30,
                          ),
                        ),
                      ),
                      Marker(
                        point: LatLng(21.0325, 105.8482),
                        child: Container(
                          child: Icon(
                            Icons.delivery_dining,
                            color: Colors.green,
                            size: 30,
                          ),
                        ),
                      ),
                    ],
                  ),
                ],
              ),

              // GPS Status Panel (top)
              Positioned(
                top: 50,
                left: 16,
                right: 16,
                child: Consumer<AuthProvider>(
                  builder: (context, authProvider, child) {
                    return Container(
                      padding:
                          EdgeInsets.symmetric(horizontal: 16, vertical: 8),
                      decoration: BoxDecoration(
                        color: authProvider.isOnline
                            ? Colors.green[50]
                            : Colors.grey[50],
                        borderRadius: BorderRadius.circular(25),
                        border: Border.all(
                          color: authProvider.isOnline
                              ? Colors.green
                              : Colors.grey,
                          width: 2,
                        ),
                        boxShadow: [
                          BoxShadow(
                            color: Colors.black12,
                            blurRadius: 6,
                            offset: Offset(0, 2),
                          ),
                        ],
                      ),
                      child: Row(
                        children: [
                          Icon(
                            authProvider.isOnline
                                ? Icons.gps_fixed
                                : Icons.gps_off,
                            color: authProvider.isOnline
                                ? Colors.green
                                : Colors.grey,
                            size: 20,
                          ),
                          SizedBox(width: 8),
                          Expanded(
                            child: Column(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              mainAxisSize: MainAxisSize.min,
                              children: [
                                Text(
                                  authProvider.isOnline
                                      ? 'ONLINE - GPS TRACKING'
                                      : 'OFFLINE',
                                  style: TextStyle(
                                    fontWeight: FontWeight.bold,
                                    fontSize: 12,
                                    color: authProvider.isOnline
                                        ? Colors.green[700]
                                        : Colors.grey[600],
                                  ),
                                ),
                                if (authProvider.isOnline &&
                                    _currentPosition != null)
                                  Text(
                                    'üìç ${_currentPosition!.latitude.toStringAsFixed(6)}, ${_currentPosition!.longitude.toStringAsFixed(6)}',
                                    style: TextStyle(
                                        fontSize: 10, color: Colors.grey[600]),
                                  )
                                else if (authProvider.isOnline)
                                  Text(
                                    _locationStatus,
                                    style: TextStyle(
                                        fontSize: 10, color: Colors.grey[600]),
                                  ),
                              ],
                            ),
                          ),
                          if (authProvider.isOnline && _currentPosition != null)
                            IconButton(
                              onPressed: () {
                                _mapController.move(
                                    LatLng(_currentPosition!.latitude,
                                        _currentPosition!.longitude),
                                    16.0);
                              },
                              icon: Icon(Icons.my_location,
                                  size: 20, color: Colors.blue),
                              constraints:
                                  BoxConstraints(minWidth: 32, minHeight: 32),
                              padding: EdgeInsets.zero,
                            ),
                        ],
                      ),
                    );
                  },
                ),
              ),

              // Menu button overlay
              Positioned(
                top: 120,
                left: 16,
                child: Builder(
                  builder: (context) => FloatingActionButton(
                    heroTag: "menu",
                    mini: true,
                    backgroundColor: Colors.white,
                    foregroundColor: Colors.black87,
                    elevation: 4,
                    onPressed: () => Scaffold.of(context).openDrawer(),
                    child: const Icon(Icons.menu),
                  ),
                ),
              ),

              // Status card overlay - Thu nh·ªè v√† di chuy·ªÉn xu·ªëng th·∫•p h∆°n
              Positioned(
                bottom: 140,
                left: 16,
                right: 16,
                child: Card(
                  elevation: 6,
                  shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(12),
                  ),
                  child: Padding(
                    padding:
                        const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                    child: Row(
                      children: [
                        Container(
                          width: 8,
                          height: 8,
                          decoration: BoxDecoration(
                            color: authProvider.statusColor,
                            shape: BoxShape.circle,
                          ),
                        ),
                        const SizedBox(width: 8),
                        Expanded(
                          child: Text(
                            authProvider.statusText,
                            style: const TextStyle(
                              fontWeight: FontWeight.w600,
                              fontSize: 14,
                            ),
                          ),
                        ),
                        const SizedBox(width: 8),
                        Switch(
                          value: authProvider.isOnline,
                          onChanged: authProvider.isLoading
                              ? null
                              : (value) async {
                                  if (value) {
                                    bool success =
                                        await authProvider.setDriverOnline();
                                    if (success) {
                                      _initializeLocationTracking();
                                    } else if (authProvider.error != null) {
                                      ScaffoldMessenger.of(context)
                                          .showSnackBar(
                                        SnackBar(
                                          content: Text(
                                              'L·ªói: ${authProvider.error}'),
                                          backgroundColor: Colors.red,
                                        ),
                                      );
                                    }
                                  } else {
                                    await authProvider.setDriverOffline();
                                    _locationUpdateTimer?.cancel();
                                    setState(() {
                                      _locationStatus = 'ƒê√£ d·ª´ng GPS tracking';
                                      _currentPosition = null;
                                      _locationHistory.clear();
                                    });
                                  }
                                },
                          activeColor: Colors.green,
                          materialTapTargetSize:
                              MaterialTapTargetSize.shrinkWrap,
                        ),
                      ],
                    ),
                  ),
                ),
              ),

              // Quick action buttons
              Positioned(
                bottom: 20,
                right: 16,
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    FloatingActionButton(
                      heroTag: "location",
                      mini: true,
                      backgroundColor: Colors.white,
                      foregroundColor: Colors.blue,
                      onPressed: _currentPosition != null
                          ? () {
                              _mapController.move(
                                  LatLng(_currentPosition!.latitude,
                                      _currentPosition!.longitude),
                                  16.0);
                            }
                          : null,
                      child: const Icon(Icons.my_location),
                    ),
                    const SizedBox(height: 8),

                    // N√∫t g·ª≠i t·ªça ƒë·ªô l√™n Firebase
                    FloatingActionButton(
                      heroTag: "firebase_location",
                      mini: true,
                      backgroundColor: Colors.orange,
                      foregroundColor: Colors.white,
                      onPressed: () async {
                        await _sendLocationToFirebase();
                      //   _sendLocationToFirebaseFromGetLocation
                      },
                      child: const Icon(Icons.cloud_upload),
                    ),

                    SizedBox(height: 8,),

                    // N√∫t ki·ªÉm tra kho·∫£ng c√°ch t·ª± ƒë·ªông
                    FloatingActionButton(
                      heroTag: "check_proximity",
                      mini: true,
                      backgroundColor: _isAutoProximityChecking ? Colors.red : Colors.purple,
                      foregroundColor: Colors.white,
                      onPressed: () async {
                        _toggleAutoProximityChecking();
                      },
                      child: Icon(_isAutoProximityChecking ? Icons.stop : Icons.location_on),
                    ),

                    SizedBox(height: 8,),
                    FloatingActionButton(
                      heroTag: "orders",
                      backgroundColor: Colors.green,
                      foregroundColor: Colors.white,
                      onPressed: () {
                        Navigator.push(
                          context,
                          MaterialPageRoute(
                              builder: (context) => const OrdersScreen()),
                        );
                      },
                      child: const Icon(Icons.assignment),
                    ),
                  ],
                ),
              ),
            ],
          );
        },
      ),
    );
  }

  Widget _buildDrawer(BuildContext context) {
    return Consumer<AuthProvider>(
      builder: (context, authProvider, child) {
        return Drawer(
          child: Column(
            children: [
              // Header with user info
              GestureDetector(
                onTap: () {
                  Navigator.pop(context);
                  Navigator.push(
                    context,
                    MaterialPageRoute(
                        builder: (context) => const ProfileDetailScreen()),
                  );
                },
                child: Container(
                  width: double.infinity,
                  decoration: BoxDecoration(
                    gradient: LinearGradient(
                      colors: [Colors.green.shade700, Colors.green.shade500],
                      begin: Alignment.topLeft,
                      end: Alignment.bottomRight,
                    ),
                  ),
                  child: SafeArea(
                    child: Padding(
                      padding: const EdgeInsets.all(16.0),
                      child: Column(
                        mainAxisSize: MainAxisSize.min,
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          // Avatar
                          CircleAvatar(
                            radius: 30,
                            backgroundColor: Colors.white,
                            child:
                                authProvider.driver?.avatar?.isNotEmpty == true
                                    ? ClipRRect(
                                        borderRadius: BorderRadius.circular(30),
                                        child: Image.network(
                                          authProvider.driver!.avatar!,
                                          width: 60,
                                          height: 60,
                                          fit: BoxFit.cover,
                                          errorBuilder:
                                              (context, error, stackTrace) {
                                            return Icon(
                                              Icons.person,
                                              size: 30,
                                              color: Colors.green.shade700,
                                            );
                                          },
                                        ),
                                      )
                                    : Icon(
                                        Icons.person,
                                        size: 30,
                                        color: Colors.green.shade700,
                                      ),
                          ),
                          const SizedBox(height: 12),
                          // Name
                          Text(
                            authProvider.driver?.name ?? 'Tr∆∞∆°ng Xu√¢n Ki√™n',
                            style: const TextStyle(
                              color: Colors.white,
                              fontSize: 16,
                              fontWeight: FontWeight.bold,
                            ),
                            maxLines: 1,
                            overflow: TextOverflow.ellipsis,
                          ),
                          const SizedBox(height: 4),
                          // Phone
                          Text(
                            authProvider.driver?.phoneNumber ?? '',
                            style: const TextStyle(
                              color: Colors.white70,
                              fontSize: 12,
                            ),
                            maxLines: 1,
                            overflow: TextOverflow.ellipsis,
                          ),
                          const SizedBox(height: 8),
                          // Tap hint
                          Text(
                            '‚úèÔ∏è Nh·∫•n ƒë·ªÉ xem chi ti·∫øt',
                            style: const TextStyle(
                              color: Colors.white60,
                              fontSize: 11,
                              fontStyle: FontStyle.italic,
                            ),
                          ),
                        ],
                      ),
                    ),
                  ),
                ),
              ),

              // Menu items
              Expanded(
                child: ListView(
                  padding: EdgeInsets.zero,
                  children: [
                    _buildMenuItem(
                      icon: Icons.home,
                      title: 'Trang ch·ªß',
                      onTap: () {
                        Navigator.pop(context);
                      },
                    ),
                    _buildMenuItem(
                      icon: Icons.person,
                      title: 'Th√¥ng tin c√° nh√¢n',
                      onTap: () {
                        Navigator.pop(context);
                        Navigator.push(
                          context,
                          MaterialPageRoute(
                              builder: (context) =>
                                  const ProfileDetailScreen()),
                        );
                      },
                    ),
                    _buildMenuItem(
                      icon: Icons.delivery_dining,
                      title: 'ƒê∆°n ƒëang giao',
                      onTap: () {
                        Navigator.pop(context);
                        Navigator.push(
                          context,
                          MaterialPageRoute(
                              builder: (context) => const OrdersScreen()),
                        );
                      },
                    ),
                    _buildMenuItem(
                      icon: Icons.share,
                      title: 'Chia s·∫ª chuy·∫øn ƒëi',
                      onTap: () {
                        Navigator.pop(context);
                        Navigator.push(
                          context,
                          MaterialPageRoute(
                              builder: (context) => const TripSharingScreen()),
                        );
                      },
                    ),
                    _buildMenuItem(
                      icon: Icons.bar_chart,
                      title: 'Th·ªëng k√™',
                      onTap: () {
                        Navigator.pop(context);
                        Navigator.push(
                          context,
                          MaterialPageRoute(
                              builder: (context) => const StatisticsScreen()),
                        );
                      },
                    ),
                    _buildMenuItem(
                      icon: Icons.history,
                      title: 'L·ªãch s·ª≠ chuy·∫øn ƒëi',
                      onTap: () {
                        Navigator.pop(context);
                        Navigator.push(
                          context,
                          MaterialPageRoute(
                              builder: (context) => const HistoryScreen()),
                        );
                      },
                    ),
                    _buildMenuItem(
                      icon: Icons.people,
                      title: 'M·ªùi b·∫°n b√®',
                      onTap: () {
                        Navigator.pop(context);
                        Navigator.push(
                          context,
                          MaterialPageRoute(
                              builder: (context) =>
                                  const InviteFriendsScreen()),
                        );
                      },
                    ),
                    _buildMenuItem(
                      icon: Icons.settings,
                      title: 'Thi·∫øt l·∫≠p',
                      onTap: () {
                        Navigator.pop(context);
                        Navigator.push(
                          context,
                          MaterialPageRoute(
                              builder: (context) => const SettingsScreen()),
                        );
                      },
                    ),
                    const Divider(),
                    _buildMenuItem(
                      icon: Icons.location_searching,
                      title: 'GPS Test',
                      onTap: () {
                        Navigator.pop(context);
                        Navigator.push(
                          context,
                          MaterialPageRoute(
                              builder: (context) => const GPSTestScreen()),
                        );
                      },
                    ),
                    _buildMenuItem(
                      icon: Icons.logout,
                      title: 'ƒêƒÉng xu·∫•t',
                      onTap: () {
                        Navigator.pop(context);
                        _logout();
                      },
                    ),
                  ],
                ),
              ),
            ],
          ),
        );
      },
    );
  }

  Widget _buildMenuItem({
    required IconData icon,
    required String title,
    required VoidCallback onTap,
  }) {
    return ListTile(
      leading: Icon(icon, color: Colors.grey.shade600),
      title: Text(
        title,
        style: TextStyle(
          color: Colors.grey.shade800,
          fontSize: 16,
        ),
      ),
      onTap: onTap,
    );
  }

  void _logout() async {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('ƒêƒÉng xu·∫•t'),
        content: const Text('B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën ƒëƒÉng xu·∫•t?'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('H·ªßy'),
          ),
          TextButton(
            onPressed: () async {
              Navigator.pop(context); // Close dialog first

              try {
                // Stop location tracking immediately
                _locationUpdateTimer?.cancel();

                final authProvider =
                    Provider.of<AuthProvider>(context, listen: false);
                await authProvider.logout();

                // Navigate to login with a slight delay to ensure logout completes
                if (mounted) {
                  Navigator.pushAndRemoveUntil(
                    context,
                    MaterialPageRoute(
                      builder: (context) =>
                          const PhoneInputScreen(isLogin: true),
                    ),
                    (route) => false,
                  );
                }
              } catch (e) {
                print('‚ùå Logout error: $e');
                // Still navigate to login even if logout fails
                if (mounted) {
                  Navigator.pushAndRemoveUntil(
                    context,
                    MaterialPageRoute(
                      builder: (context) =>
                          const PhoneInputScreen(isLogin: true),
                    ),
                    (route) => false,
                  );
                }
              }
            },
            child: const Text('ƒêƒÉng xu·∫•t'),
          ),
        ],
      ),
    );
  }
}
